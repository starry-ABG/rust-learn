# Fn

在Rust中经常遇到闭包与函数指针在泛型中限定类型，让人感到迷惑。

总的来说Rust中的函数、函数指针、闭包都是建立在FnOnce、FnMut、Fn三个trait的基础之上的，理解了这三个trait以及编译器的作用，才能对其理解。

## AI解释

下面对Rust中函数、函数指针、闭包，以及 `Fn`、`FnMut`、`FnOnce` 这几个概念的层次关系和内在联系进行梳理，并从易到难地提出一系列问题，以帮助读者逐步理解整个系统的运作原理。

### 基础概念梳理

1. **函数（Function）**

   - 使用 `fn` 关键字定义的普通函数，如 `fn add(a: i32, b: i32) -> i32 { a + b }`。
   - 编译期已知代码体，不捕获外部变量。
   - 可直接调用，或通过函数指针间接调用。

2. **函数指针（Function Pointer）**

   - 类型形如 `fn(i32) -> i32`，表示指向特定函数的指针。
   - 没有状态，不捕获环境变量，纯粹指向某块可执行代码。
   - 函数指针实现了 `Fn`、`FnMut`、`FnOnce`（实际上最低要求的`FnOnce`层级，它都满足，并因此满足更高级别的`Fn`和`FnMut`），可作为“无状态闭包”使用。

3. **闭包（Closure）**

   - 使用 `||` 定义的匿名函数块，如 `|x| x + 1`。

   - 可以捕获定义处的外部变量（通过不可变借用、可变借用、或移动所有权），因而有内部状态。

   - 根据捕获方式及调用方式的需求，闭包会自动实现 

     ```
     FnOnce
     ```

     、

     ```
     FnMut
     ```

     、

     ```
     Fn
     ```

     之一或多个。捕获方式从轻到重：

     - 只读借用（&） ⇒ `Fn`
     - 可变借用（&mut） ⇒ `FnMut`
     - 按值捕获（move） ⇒ `FnOnce`

4. **Fn、FnMut、FnOnce 三大特征**

   - `FnOnce`: 至少能调用一次，调用时可消耗闭包的内部资源。
   - `FnMut`: 在 `FnOnce`基础上可多次调用，但需要可变引用，允许修改闭包内部状态。
   - `Fn`: 在 `FnMut`的基础上进一步要求多次调用且只需不可变引用，不可修改内部状态。

   继承关系为：`Fn` ⊇ `FnMut` ⊇ `FnOnce`。
    也就是说，`Fn`是最严格、最高级别的约束，`FnOnce`是最宽松、最低的要求。

### 层次与关系小结

- **函数**是基础的可调用代码块，不捕获环境。
- **函数指针**是指向函数的指针，实现了`Fn`，可看作无状态的“闭包”。
- **闭包**是可以捕获环境的匿名可调用对象，编译器为闭包选择合适的`Fn`特征来实现。

### 从浅入深提出问题帮助理解

1. **基础问题（理解函数与函数指针）**
   - 问题：在Rust中，`fn add(a: i32, b: i32) -> i32`这样的函数和 `let f: fn(i32, i32) -> i32 = add;`这样的函数指针有何区别？
   - 启示：通过这个问题理解函数与函数指针的关系，函数指针只是一个指向函数的变量。
2. **函数指针与Fn的联系**
   - 问题：为什么当我们在高阶函数中要求`F: Fn(i32) -> i32`时，既可以传入闭包，也可以传入函数指针？
   - 启示：此问题引导读者思考函数指针与`Fn`特征的关系，了解函数指针天然实现`Fn`的原因。
3. **闭包的核心特性**
   - 问题：闭包是如何捕获外部变量的？什么情况下闭包只是借用变量，什么情况下会得到变量的所有权？
   - 启示：帮助理解闭包的捕获模式（&、&mut、move）对后续`Fn`、`FnMut`、`FnOnce`特征的实现有何影响。
4. **从捕获方式到特征实现的推理**
   - 问题：给定一个闭包，它对外部变量进行了可变修改，那么它会实现`Fn`、`FnMut`还是`FnOnce`？为什么？
   - 启示：通过具体实例，让读者将捕获方式和特征实现对应起来。
5. **特征层次关系**
   - 问题：为什么`Fn`特征的实现者也一定实现`FnMut`和`FnOnce`，但反过来不一定成立？
   - 启示：帮助理解`Fn`、`FnMut`、`FnOnce`的子集关系，以及为什么`Fn`是最高层级的要求。
6. **泛型约束与可调用对象**
   - 问题：当函数定义为`fn apply<F: Fn(i32) -> i32>(f: F, x: i32) -> i32`时，传入`f`的是函数、闭包还是函数指针？或是都可以？
   - 启示：强调`Fn`特征的多态性，让读者理解在这种类型签名中函数、闭包、函数指针都可通用。
7. **实现细节与编译器行为**
   - 问题：编译器在背后是如何将闭包转换为结构体，并为其自动实现`FnOnce`、`FnMut`或`Fn`？
   - 启示：引导读者了解编译器在MIR/LLVM IR层面对闭包所做的工作，为深入研究Rust编译器实现打下基础。
8. **扩展思考**
   - 问题：如果有一个闭包需要在调用后消耗所捕获的资源，但我又想多次调用它，该如何改写代码？
   - 启示：通过这种问题，读者会思考如何改变捕获方式（例如改用借用）来提升闭包实现特征的“等级”（从`FnOnce`到`FnMut`或`Fn`）。

### 总结

从最简单的函数到函数指针，再到闭包及其背后的`FnOnce`、`FnMut`、`Fn`特征体系，Rust提供了一套灵活又严格的机制来处理可调用对象。通过上述问题的层层递进，可以让读者：

- 先理解函数与函数指针的基本概念与关系。
- 再认识闭包的捕获行为对其特征实现的影响。
- 最终明白`Fn`、`FnMut`、`FnOnce`的层级和闭包编译原理，从而全面理解Rust中可调用对象系统的设计与运作方式。
